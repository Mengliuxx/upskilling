C语言编译过程知识点梳理： 
    1 从语言编译成可执行程序进过4步：gcc -o test test.c
        预处理：gcc -E hello.c -o hello.i
	编译：  gcc -S hello.i -o hello.s
	汇编：  gcc -c hello.o -o hello.o
	链接：  gcc    hello.o -o hello

	a. 预处理：头文件展开，宏定义展开，条件编译等，同时将代码中的注释删除，这里也不会检查语法错误
		头文件展开：#include <stdio.h> 包含文件stdio.h（预处理阶段将stdio.h文件拷贝至预处理文件）
		删除注释：两种方式 //，  /* */
		宏替换： #define 代表声明一个宏，在预处理阶段将宏替换掉
		条件编译：条件不成立 #if 0 -> #endif  条件成立 #if 1 -> #endif
		不会检查语法错误：
	
	b. 编译：
                检查语法错误，将预处理文件编译成汇编文件。
	c. 汇编：
		将汇编文件编译生成二进制文件 .o
	d. 链接：
		设置运行环境，堆栈等，链接其它库文件

    2 system 库函数
	作用：在程序中启动另一个程序
	参数：可执行程序的路径和名称

    3 寄存器 缓存cpu内存之间的关系
	cpu > 寄存器 > 缓存 > 内存

    4.vs出现4996告警编号
 	只要在文件的最开始一行添加告警屏蔽
	1.#define CRT_SECURE_NO_WARNINGS  
	2.#pragma warning (disable:4996)	

    5. 数据类型：
	作用：编译器预算数据在内存中需要多大的空间
	
	常量：程序运行汇总不能改变的量
		整数常量：1 200
		字符常量：'a'
		字符串常量： 'hello'
		浮点型常量： 3.14

	变量：程序运行中课可以被改变的量，存在于内存中
	      变量需要需要定义：
	      定义：在内存中开辟空间，告诉编译器我有这个变量（声明）	
	      变量的定义形式： 数据类型 变量名  int a

              类型      内存          
	      int  	4字节				
	      short	2字节
	      long	在windows 4字节，
	      		Linux 32位4字节，64位8字节
	      long long	8字节
	      char 	1字节	 
	      float 	4字节
	      double	8字节
	定义：在内存开辟空间
	初始化： 定义时赋值；
	声明：没有开辟内存空间  extern告诉编译器这里有个变量


	5.2 有符号和无符号
		signed char num: 最高的bit为作为符号位，1 负数，0 正数。
		unsigned char num :没有符号位，全部为数据位。
		
            数的范围：
	    类型    字节         		范围
	    char    1   signed char     -128 ~ 127  (-2^7 ~ 2^7-1) 
	    		unsigned char   0 ~ 255     (0 ~ 2^8 -1)
	    short   2   signed short     (-2^15 ~ 2^15-1)
			unsigned short   (0 ~ 2^16 -1)
	    int     4   signed int 	(-2^31 ~ 2^31 -1)
	    		unsigned int    (0 ~ 2^32-1)  
			
	5.3 原码
		数的最原始的二进制码
		a. 负数如果在计算中用原码存储，会导致两个问题，负数运算结果不正确，0的结果有两种。
		-0：1000 0000	-1:1000 0001
		+0: 0000 0000	+1:0000 0001
		-1+1 = 1000 0010 = -2 ?
	5.4 反码
		正数的反码不变，负数的反码（符号位不变，其余位取反）
		-1的反码：1111 1110 
		-1 + 1 =  1111 1111 = -0的反码
		b. 如果计算机用反码去存，负数运算结果正确，但是0的状态还是有两种。
	5.5 补码
		正数的补码不变，负数的补码等于反码加1
		-1:1111 1111 
		-1 + 1 = 1 0000 0000 取8位 = 0000 0000  = 0
		c. 如果计算机用补码去存，运算结果正确，0的状态也正确。
		
	注意：
		赋值时（输入），赋值时十进制给的是原码，如果是八进制或十六进制给的是补码
		打印时（输出），十进制打印的是原码，八进制或者十六进制给的数是补码。

	5.6 补码求原码
		原码 = 补码取反 + 1


    6. 限定符
	const修饰：修饰的变量不能通过变量名去修改。
	extern： 告诉编译器有这个声明，没有开辟空间
	volatile： 防止编译器优化代码。
	register：建议将变量定义在寄存器中。


    7. 浮点型数据
	float 类型能够保证的精度是7位有效数字
	double 类型能够保证的精度是15位有效数字

    8. 字符与字符串
	字符类型用单引号 ''表示 : 'a'
	字符串类型用双引号 ""表示： "a" ，实际在a后面有'\0'追加


    9. 运算符号优先级
	逗号运算符，使用最后一个表达式的值；
	eg： int a = (3, 4, 6, 7, 9, 100+1); a的值为100+1

10.数组
　　　int a[2][3]
　　　
　　　a[0][0]   第0行第0个元素
　　　&a[0][0]  第0行第0个元素的地址
　　　a[0] 代表第0行一维数组的数组名 a[0]=&a[0][0] 
　　　&a[0] 第0行的地址
　　　a 二维数组组名，代表二维数组，也代表首行地址 &a[0]
　　　&a 二维数组的地址
　　　
　　　&a[0][0] + 1  元素地址加1，跨过一个元素
　　　a[0] + 1 元素地址加1，跨过一个元素
　　　&a[0] + 1 行地址加1，跨过一行
　　　a + 1 行地址加1，跨过1行
　　　&a + 1 二维数组地址加1， 跨过整个数组
　　　

　　　字符串输入：
　　　char  num[128] = {0};
　　　1.sacnf(“%s”, num);//num就代表了数组的首地址
　　　缺点：scanf %s 格式读取，遇到\n结束，遇到空格结束，如果超过内存空间会造成内存污染。
　　　2.gets(num)//里面参数为存放读取字符串的地址
     遇到空格是可以读取的
　　　3.fgets(num, sizeof(num), stdin)//从stdin读取最大sizeof(num)-1 的字符到num里面。
fgets会将空格\n都读取，导致读取结束的时候会有\n.例如”hello\n”;
所以，需要将最后一个字符置为0， num[strlen(num) - 1] = ‘\0’
　　　strlen(num)， 遇到’\0’停止，不计算在内


五、函数
1. 函数的返回值小于4字节存储在寄存器中，大于4字节存在内存中。
2. return()和exit()的区别：return结束当前函数；
   exit();是系统库函数，调用后结束整个程序。
3.防止头文件重复包含：
(1)#ifndef 宏(头文件名字)
　　　#endif
(2)#pragma once

六、内存与指针
1.在使用指针时，对一个表达式取*就会对表达式减一级*，如果对表达式取&，就会加一级。
2. 不管什么类型的指针，大小只和编译器有关。
3. 不同类型的指针变量，取指针指向的内容宽度(步长：指针+1跨过的字节)不同；
　　　指针宽度 = size(将指针变量与指针变量最近的*拖黑，剩下的类型)
　　　Char  *p   1
　　　Short *p   2
　　　Int   *p   4
4.野指针：没有初始化的指针。
5.空指针：int *p = NULL;给指针p的内容赋值为0，地址为0x0000 0000, NULL仅仅判断指针是否被使用。


	